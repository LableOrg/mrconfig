#!/usr/bin/env python
# -*- coding: UTF-8 -*-

from __future__ import print_function

import argparse
import sys
import os
import tempfile
import StringIO
import ConfigParser
import textwrap
import logging
from subprocess import call
from os.path import expanduser

from kazoo.client import KazooClient
from kazoo.client import KazooState
from kazoo.exceptions import NoNodeError

# Program version.
VERSION = "0.5"

# The possible locations of this program's configuration file.
CONF_IN_HOME_DIR = expanduser('~/.mrconfig')
ETC_DIRS = ['/etc', '/usr/local/etc']
CONF_IN_ETC = 'mrconfig.conf'

EDITOR = os.environ.get('EDITOR', 'vim')
DEFAULT_TEMP_FILE_EXTENSION = '.txt'


def read_from_config(path):
    """Read the options needed to connect to a ZooKeeper quorum from a file."""

    try:
        with open(path, 'r') as conf:
            conf_str = '[root]\n' + conf.read()
            conf_fp = StringIO.StringIO(conf_str)
            config = ConfigParser.RawConfigParser()
            config.readfp(conf_fp)
    except IOError:
        logging.warn("Failed to read config file at {0}.".format(path))
        return

    for option in ("zookeeper_quorum", "configuration_znode", "default_file_extension"):
        try:
            options[option] = config.get('root', option)
            logging.info("Read option `{0}' from {1}: {2}".format(option, path, options[option]))
        except ConfigParser.NoOptionError:
            logging.info("Option `{0}' not configured in settings file.".format(option))


def check_options_or_exit(quiet):
    """Check if the required options were set, and quit if that is not the case."""

    if not "zookeeper_quorum" in options or not "configuration_znode" in options:
        if not quiet:
            message = ("Look, I can't connect to the ZooKeeper quorum without its address and the path "
                       "to the configuration root znode. "
                       "Either add a configuration file in ~/.mrconfig or /etc/mrconfig.conf, "
                       "or pass these parameters as arguments.")
            print("Hello there!")
            print("")
            print(textwrap.fill(message, 80))
        sys.exit(2)


def check_config_znode_or_quit(znode, quiet):
    """Check if a node exists, and quit if it doesn't."""

    if zookeeper.exists(znode) is None:
        if not quiet:
            print("Znode {0} does not exist (yet).".format(znode), file=sys.stderr)
        exit_with_error()


def path_from(parent, child):
    """Join the name of parent node with a child name into a complete valid path."""

    if parent[-1:] == "/":
        return parent + child
    else:
        return parent + "/" + child


def connect(quiet, read_only=False):
    """Connect to the ZooKeeper quorum, and assert that the root configuration node exists."""

    check_options_or_exit(quiet)

    logging.info("Connecting to ZooKeeper quorum at {0}. Znode is {1}.".format(
        options["zookeeper_quorum"], options["configuration_znode"]))

    global zookeeper
    zookeeper = KazooClient(hosts=options["zookeeper_quorum"], read_only=read_only)
    zookeeper.start()
    if not zookeeper.state == KazooState.CONNECTED:
        if not quiet:
            print("Connection to ZooKeeper quorum failed, check your settings.", file=sys.stderr)
        exit_with_error()

    check_config_znode_or_quit(options["configuration_znode"], quiet)


def close_connection():
    """Close the ZooKeeper connection."""
    if zookeeper is not None:
        zookeeper.stop()
        zookeeper.close()


def exit_with_error():
    """"Close the ZooKeeper connection and exit with a non-zero exit status."""
    close_connection()
    sys.exit(2)


def read_from_file_or_stdin(filename):
    """Read the contents of named file, or from stdin if filename is '-'."""
    if filename == '-':
        # Read from stdin when - is passed as filename.
        content = sys.stdin.read()
    else:
        with open(filename, "r") as f:
            content = f.read()
    return content


def set_config(name, content, quiet):
    """Upload the contents for the named configuration node."""

    znode = options["configuration_znode"]
    conf_node = path_from(znode, name)

    conf_node_exists = (zookeeper.exists(conf_node) is not None)

    # noinspection PyBroadException
    try:
        if conf_node_exists:
            zookeeper.set(conf_node, content)
        else:
            zookeeper.ensure_path(znode)
            zookeeper.create(conf_node, content)
    except:
        # Catch all exceptions here.
        if not quiet:
            print("Unexpected error:", sys.exc_info()[0])
        exit_with_error()
    else:
        if not quiet:
            print("Node {0} successfully written.".format(conf_node))


def get_config(name, quiet, raise_if_no_such_node=False):
    """Download the contents of a node."""

    znode = options["configuration_znode"]
    conf_node = path_from(znode, name)
    try:
        content = zookeeper.get(conf_node)[0]
    except NoNodeError:
        if raise_if_no_such_node:
            raise
        if not quiet:
            print("Node does not exist: {0}".format(conf_node), file=sys.stderr)
        exit_with_error()
    else:
        return content.rstrip()


def delete_config(name, quiet):
    """Delete a node, if it exists."""

    znode = options["configuration_znode"]
    conf_node = path_from(znode, name)
    try:
        zookeeper.delete(conf_node)
    except NoNodeError:
        # Node is already gone, but we treat this as success because deleting
        # the node was the goal.
        if not quiet:
            print("Node does not exist: {0}.".format(conf_node))
        sys.exit(0)
    else:
        if not quiet:
            print("Successfully deleted node {0}.".format(conf_node))


def list_configs():
    """Print a list of all the configuration nodes directly under the parent node."""

    znode = options["configuration_znode"]
    children = zookeeper.get_children(znode)
    children.sort()

    print(znode)
    if len(children) == 0:
        print("  (no child nodes)")
    else:
        # Print the children with a character-art path in front of it.
        prev = None
        for child in children:
            if prev is not None:
                print(" {0} {1}".format("├", prev))
            prev = child
        print(" {0} {1}".format("└", prev))


def edit_config_with_favorite_editor(name, content):
    """Edit text in $EDITOR, or vim if no editor is configured."""

    file_extension = os.path.splitext(name)[1]
    if file_extension == "":
        if "default_file_extension" in options:
            suffix = options["default_file_extension"]
        else:
            suffix = DEFAULT_TEMP_FILE_EXTENSION
    else:
        suffix = file_extension

    # Ensure a period is placed before the file extension.
    if suffix[0] != '.':
        suffix = '.' + suffix

    with tempfile.NamedTemporaryFile(suffix=suffix, delete=False) as temp_file:
        logging.info("Writing content to temporary file at: {0}".format(temp_file.name))
        temp_file.write(content)
        temp_file.flush()
        call([EDITOR, temp_file.name])
        temp_file_name = temp_file.name

    with open(temp_file_name, "r") as temp_file:
        new_content = temp_file.read()

    os.remove(temp_file_name)

    return new_content


def user_confirms_action(query, name):
    """Ask the user if he really intended to perform the requested action, and return True if he did."""
    query += " (y/n): "
    print(query.format(name), end="")
    while True:
        try:
            choice = raw_input().lower()
            if choice == "y":
                return True
            elif choice == "n":
                return False
        except KeyboardInterrupt:
            # Clean exit on Ctrl+C.
            exit_with_error()


if __name__ == '__main__':
    """Gather arguments and prepare logging."""

    options = {}

    # Configure argparse with all the options for this program.
    parser = argparse.ArgumentParser(add_help=False,
                                     formatter_class=argparse.RawDescriptionHelpFormatter,
                                     description="Manage configuration files stored in a ZooKeeper quorum.",
                                     epilog="To write the contents of stdin to a configuration node, do something "
                                            "like this: "
                                            "\n\n"
                                            "    cat MyConf.yml | mrconfig --set NAME -"
                                            "\n\n")

    # General help and usage.
    parser.add_argument("-h", "--help",
                        help="Show this help message and exit.",
                        action="help")
    parser.add_argument("--version", action="version",
                        help="Show program's version number and exit.",
                        version="%(prog)s " + VERSION)
    parser.add_argument("-v", "--verbose", default=0,
                        help="Be a bit more chatty about what we're doing.",
                        action="count")
    parser.add_argument("-q", "--quiet", action="store_true",
                        help="Suppress all output (overrides verbosity).")

    # The main modes of operation. These are mutually exclusive; only one task can be performed
    # at a time.
    mode_group = parser.add_mutually_exclusive_group()
    mode_group.add_argument("-l", "--list", action="store_true",
                            help="List all the configs stored in the ZooKeeper quorum.")
    mode_group.add_argument("--set", nargs=2, metavar=("NAME", "FILE"),
                            help="Upload a configuration file and place it under this name.")
    mode_group.add_argument("--get", metavar="NAME",
                            help="Download named config and output it to stdout.")
    mode_group.add_argument("--edit", metavar="NAME",
                            help="Edit named config in an editor.")
    mode_group.add_argument("--delete", metavar="NAME",
                            help="Delete named config. This action cannot be undone!")
    mode_group.add_argument("--delete-without-confirmation", metavar="NAME",
                            help="Delete named config without asking for confirmation. This action cannot be undone!")

    # ZooKeeper settings. These override any settings found in the mrconfig settings file.
    parser.add_argument("--zookeepers", help="Comma-separated address of the ZooKeeper quorum.")
    parser.add_argument("--config-znode", help="Path to the root configuration znode.")

    if len(sys.argv) == 1:
        # Print help when no arguments are passed to us.
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()
    verbosity = args.verbose
    quiet = False

    if args.quiet:
        verbosity = -1
        quiet = True

    # Have the logging used match the verbosity desired by the user.
    if verbosity == 1:
        logging.basicConfig(level=logging.WARN)
    elif verbosity > 1:
        logging.basicConfig(level=logging.INFO)
    else:
        logging.basicConfig(level=logging.ERROR)

    if os.path.isfile(CONF_IN_HOME_DIR):
        # User settings, these take precedence over system settings.
        read_from_config(CONF_IN_HOME_DIR)
    else:
        for conf_dir in ETC_DIRS:
            conf_file = os.path.join(conf_dir, CONF_IN_ETC)
            if os.path.isfile(conf_file):
                # System settings.
                read_from_config(conf_file)
                break

    # Optional arguments. Usually these would be loaded from a configuration file.
    # This provides a way to override that.
    if args.zookeepers:
        options["zookeeper_quorum"] = args.zookeepers
    if args.config_znode:
        options["configuration_znode"] = args.config_znode

    zookeeper = None
    # Choose a mode of operation.
    if args.list:
        # List all configuration nodes.
        connect(quiet, read_only=True)
        list_configs()
        close_connection()
    elif args.set:
        # Set configuration.
        connect(quiet)
        new_config = read_from_file_or_stdin(args.set[1])
        set_config(args.set[0], new_config, quiet)
        close_connection()
    elif args.get:
        # Get configuration and output to stdout.
        connect(quiet, read_only=True)
        print(get_config(args.get, quiet))
        close_connection()
    elif args.edit:
        connect(quiet)
        old_config = ""
        try:
            # Read the existing configuration node, if it exists.
            old_config = get_config(args.edit, quiet, raise_if_no_such_node=True)
        except NoNodeError:
            # Node does not exist yet. Ask the user if he wanted to create one.
            if not user_confirms_action("Configuration node '{0}' does not exist, do you want to create it?",
                                        args.edit):
                exit_with_error()
        new_config = edit_config_with_favorite_editor(args.edit, old_config)
        set_config(args.edit, new_config, quiet)
        close_connection()
    elif args.delete:
        # Remove a configuration node, but only if the user confirms this action.
        if not user_confirms_action("Are you sure you want to delete configuration node '{0}'?",
                                    args.delete):
            exit_with_error()
        connect(quiet)
        delete_config(args.delete, quiet)
        close_connection()
    elif args.delete_without_confirmation:
        # Remove a configuration node.
        connect(quiet)
        delete_config(args.delete_without_confirmation, quiet)
        close_connection()
    else:
        if not quiet:
            print("Please choose the operation you want to perform: --list, --get, --set, or --edit.")
            print()
            parser.print_help()
        sys.exit(1)
